[{"title":"JS之标准对象","path":"2017/04/19/JS之标准对象/","text":"Datevar now = new Date();new Date().getTime(); //返回当前时间戳Date.now(); //返回当前时间戳 需要注意的是 now.getMonth(); //月份，范围是0-11, JSON对象序列化: stringify ( value [ , replacer [ , space ] ] );value通常为对象或数组，replacer为用于控制筛选对象的键值，如果只想输出指定的属性，可以传入Array，也可为函数,space为输出控制 var xiaoming = &#123; name: \"小明\", age: 13, gender: true, height: 1.63, grade: null, 'middle-school': \"\\'W3c\\' Middle School\", skills: ['JS',\"Java\",\"Python\",\"Lisp\"]&#125;console.info(JSON.stringify(xiaoming,null, ' ')) 结果： &#123; \"name\": \"小明\", \"age\": 13, \"gender\": true, \"height\": 1.63, \"grade\": null, \"middle-school\": \"'W3c' Middle School\", \"skills\": [ \"JS\", \"Java\", \"Python\", \"Lisp\" ]&#125; console.info(JSON.stringify(xiaoming,['name','skills'], ' ')) 结果： &#123; \"name\": \"小明\", \"skills\": [ \"JS\", \"Java\", \"Python\", \"Lisp\" ]&#125; replacer为函数： console.info(JSON.stringify(xiaoming,function (key ,value)&#123; if(typeof value === \"string\")&#123; return value.toUpperCase() &#125; return value&#125;,\" \")) 结果： &#123; \"name\": \"小明\", \"age\": 13, \"gender\": true, \"height\": 1.63, \"grade\": null, \"middle-school\": \"'W3C' MIDDLE SCHOOL\", \"skills\": [ \"JS\", \"JAVA\", \"PYTHON\", \"LISP\" ]&#125; 如果我们还想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()方法，直接返回JSON应该序列化的数据： var xiaoming = &#123; name: \"小明\", age: 13, gender: true, height: 1.63, grade: null, 'middle-school': \"\\'W3c\\' Middle School\", skills: ['JS',\"Java\",\"Python\",\"Lisp\"], toJSON: function() &#123; return &#123; 'Name': this.name, \"Age\": this.age &#125; &#125;&#125;console.info(JSON.stringify(xiaoming,null,\" \")) 输出 &#123; \"Name\": \"小明\", \"Age\": 13&#125; 反序列化：JSON.parse()当我们需要将一个JSON格式的字符串转化为对象时 var obj = JSON.parse('&#123;\"name\":\"小明\",\"age\":14&#125;'); // Object &#123;name: '小明', age: 14&#125;console.info(obj.name,obj.age) //小明 14 JSON.parse() 还可以接受一个函数，用来转换解析出的属性： var obj = JSON.parse('&#123;\"name\":\"小明\",\"age\":14&#125;',function (key,value)&#123; if (key ==='name') &#123; return value + \"同学\" &#125; return value&#125;); console.info(obj.name) //小明同学 RegExp创建正则表示式有两种方式，一个是 /正则表达式/写出来，第二种是通过new RegExp(‘正则表达式’)创建一个RegExp对象。 var reg1 = /^j\\-s$/;var reg2 = new RegExp('^j\\\\-s$') 两者不同的，new RegExp() 写法，因为字符串转义问题，字符串的两个 \\\\ 实际上表示一个 \\ 用RegExp对象的test()测试给定字符串是否符合条件。 \\d 匹配一个数字 \\w 匹配一个字母或数字 . 匹配任意字符 \\s 匹配一个空格 若要匹配变长字符，在正则表达式中，用* 表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或者1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符 精确匹配：可以用[]表示范围 [0-9a-zA-z\\_ 匹配一个数字、字母或者下划线； [0-9a-zA-z\\_]+ 匹配至少由一个数字、字母或者下划线组成的字符串； A|B 匹配A或B ^ 表示行的开头，如 ^\\d表示必须以数字开头。 $ 表示行的结束，如 ^\\d表示必须以数字结束。 应用-切分字符串用正则表达式切字符串比用固定字符更灵活： var splitstr = \"a,b ;; c\"console.info(splitstr.split(\" \"))console.info(splitstr.split(/[\\s\\;\\,]+/)) 输出 [ 'a,b', '', ';;', 'c' ][ 'a', 'b', 'c' ] 应用-分组除了简单地判断是否匹配外，正则表达式还有提取子串的强大功能；用()表示的就是提取分组(Group); ^(\\d{3})-(\\d{3,8})$分别定义两个组，可以直接从匹配地字符串中提取出区号和本地号码： var reg3 = /^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$/console.info(reg3.exec('010-123124'))//[ '010-123124', '010', '123124']console.info(reg3.exec('010 123412'))//null 如果正则表达式定义了组，就可以在RegExp对象上用exec()方法提取子串来，成功返回Array，失败返回null 全局搜索JS的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： var r1 = /test/g;//等价于var r2 = new RegExp('test','g') 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： var s = 'JavaScript, VBScript, JScript and ECMAScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // ['JScript']re.lastIndex; // 29re.exec(s); // ['ECMAScript']re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。 var reg5 = /test/i;console.info(reg5.test(\"TeSt\")) //true","tags":[{"name":"js","slug":"js","permalink":"lindyer.github.io/source/tags/js/"}]},{"title":"JavaScript学习","path":"2017/04/18/JavaScript之变量和闭包/","text":"我回来啦。。。。。。（之前之前想试着坚持写博客来着，不得不承认缺乏坚持一直是我的缺点，我将试着改变它），由于最近工作主要用到qml（ECMAScript被设计成qml的一部分，并采用更严格的模式，貌似Qt5.8现在只支持ECMAScript 5，所以ECMAScript 6还是先放一放，这里暂时只记录ECMAScript5(下称js)的内容），Qt帮助文档搜ECMAScript Reference能看到Qt支持的js的内容，但有一点不足的是，帮助文档缺乏函数原型的介绍，返回值也没有；所以有时候得借助js的手册http://lzw.me/pages/ecmascript/ 。下面对某些知识进行摘选记录(在此鸣谢廖雪峰老师的教程) 变量作用域​ 如果一个变量在函数体内部声明，则该变量的作用域为整个函数体 ，这里面主要涉及到了变量提升，函数体内的声明的变量都会提升到函数顶部，所以这里推荐在函数顶部用var 声明函数内用到的所有变量，如下： function fn()&#123; var a = 1, b = 2,i for(i = 0, i &lt; 10; ++i)&#123; ... &#125;&#125; 另外在函数体外不可引用该变量。 闭包function sum(arr)&#123; return function() &#123; //[1] return arr.reduce(function(x,y)&#123; //[2] return x + y &#125;) &#125; &#125;var f = sum([1,2,3]) //[3]console.info(f()) //6 上面[1]中函数作为返回值，所以[3]中f还是[1]指向的函数变量（带有arr），f() 才真正计算结果。 下面看这段代码， function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];console.info(f1(),f2(),f3()) //16 16 16 count方法中，每次循环都创建一个新的函数（返回值为i*i，函数并非立刻执行），等到3个函数都返回时，他们所引用的变量i都变成了4，等到调用时它们的结果都为16 结论：返回闭包时要注意： 返回函数不要引用任何循环变量，或者后续会发生变化的变量； 如果一定要引用循环变量怎么办？方法是在创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定的函数参数的值不变： function count2()&#123; var arr = [] for (var i = 1; i &lt; 3; i++) &#123; arr.push((function (n)&#123; return function()&#123; return n*n &#125; &#125;)(i)) &#125; return arr&#125;results = count2()console.info(results[0](),results[1]()) //1 4 上面代码需要注意的是，arr调用push的是一个匿名函数并立刻执行（将i传进去，这时i已经跟arr中函数绑定） 这里说说闭包的一个主要用途： 在面向对象的程序设计语言中，比如java和c++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量，在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。用JavaScript创建一个计数器： function counter(initial)&#123; var x = initial || 0 return &#123; inc:function()&#123; return ++x &#125; &#125;&#125;var o1 = counter()console.info(o1.inc())console.info(o1.inc()) 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x, 换句话说，闭包就是携带状态的函数，并且他的状态可以完全对外隐藏起来。","tags":[{"name":"js","slug":"js","permalink":"lindyer.github.io/source/tags/js/"}]},{"title":"Cpp基本概念-翻译阶段","path":"2017/01/12/Cpp基本概念-翻译阶段/","text":"翻译阶段 ：C++源文件以如下顺序进行编译 阶段1： 源代码文件的各个字节被映射（执行定义的方式）连接到的人物基本源代码字符集。特别地，操作系统依赖的行结束指示符被换行符替换。在基本的源代码字符集包含96个字符： A） 5个空白字符（空格，水平制表符，垂直制表符，换页，换行） B）由10位字符&#39;0&#39;到&#39;9&#39; C）从52字母&#39;A&#39;到&#39;Z&#39;和&#39;A&#39;到&#39;Z&#39; D） 29标点字符：_ { } [ ] ＃（）&lt;&gt;％：; 。？* + - / ^＆| 〜！=，\\“&#39; 不能被映射到基本源字符集中的所有源文件的字符被取代其通用字符名称（逃脱\\u或\\U）或由被等效处理一些内部形式。 3） 三字符序列是由对应的单字符表示代替。（直到C ++ 17） 阶段21）当反斜杠出现在一本线（后面紧跟换行符）结束时，双方反斜杠和换行符被删除，两个物理源线组合成一个逻辑源代码行。这是单遍操作; 以两个反斜杠结尾，后跟空行的行不会将三个行合并为一个。如果通用字符名（\\ UXXX在这个阶段形成）的行为是不确定的。2）如果一个非空源文件不这一步后，新行字符结尾（无论它没有换行符原来，或者用反斜杠结束）的行为是不确定的 （直到C ++ 11）一个终止换行符加 （因为C ++ 11） 。阶段31）源文件被分解成注释，空白字符（空格，水平制表符，换行符，垂直制表符，和换页）和序列预处理标记，它有以下几种：一）标题名称，如&lt; iostream的&gt;或“myfile.h” （仅在公认 的#include）B） 标识符C）预处理号D） 字符和字符串文字，包括用户自定义的 （因为C ++ 11）E）运营商和标点符号（包括替代标记），如+, &lt;&lt;=, new, &lt;%, ##, or and F）独立非空白字符不适合在任何其他类别2）在阶段1，初始和任何最终双引号之间2执行的任何转换原始字符串字面量将恢复。（从C ++ 11开始）3）每个注释被一个空格字符替代。保留换行符，并且未指定非换行符空格序列是否可以折叠为单个空格字符。阶段41）的预处理器执行。2）用导入的每个文件的#include指令经历的阶段1至4，递归。3）在这个阶段结束时，所有的预处理器指令从源移除。阶段51）中的所有字符的字符文字和字符串文字从源字符集转换后的执行字符集（这可能是一个多字节字符集，如UTF-8，只要96字符的基本来源字符集上市阶段1具有单字节表示）。2） 转义序列被扩展并转换为和字符文字和非原始字符串字面通用字符名执行字符集。如果由通用字符名指定的字符不是执行字符集的成员，则结果是实现定义的，但是保证不是空（宽）字符。注：此阶段执行的转换可以通过命令行选项在一些实施控制：GCC和铿锵使用- finput -字符集指定源字符集编码，- fexec -字符集和- fwide - EXEC -字符集指定在字符串和字符集执行字符的编码没有编码的前缀 （因为C ++ 11） 。阶段6相邻的字符串并置。阶段7编译发生：每个预处理令牌转换为令牌。令牌在语法和语义上被分析和翻译为翻译单元。阶段8每个翻译单元进行检查，生产所需的模板实例，包括所要求的那些清单明确的实例。的模板的定义的位置，并且需要实例化被执行以产生实例化的单位。阶段9将满足外部引用所需的翻译单元，实例化单元和库组件收集到包含在其执行环境中执行所需的信息的程序映像中。","tags":[{"name":"C++","slug":"C","permalink":"lindyer.github.io/source/tags/C/"},{"name":"概念","slug":"概念","permalink":"lindyer.github.io/source/tags/概念/"}]},{"title":"Cpp知识","path":"2017/01/12/Cpp知识/","text":"sizeof 查询对象或者类型的大小，在需要知道对象的实际大小使用。 sizeof 如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。sizeof用于指针时将返回4。 语法 ：sizeof (type) 或者 sizeof expression None ,两个都返回一个std::size_t类型的常量。 解释：1）返回type类型对应对象的大小（以字节为单位）；2）返回expression的返回类型对应对象的大小。 注解： 无论 CHAR_BIT 为何值，sizeof(char)、sizeof(signed char)、sizeof(unsigned char) 总是返回 1。 sizeof 不能用于函数类型、不完全类型和位段左值。 当应用于引用类型时，其结果是被引用类型的大小。 当应用于类时，其结果是该类对象的大小与该对象放入数组时所需的填充大小的总和。 当应用于空类时，总是返回 1。 示例 #include &lt;iostream&gt;struct Empty &#123;&#125;;struct Bit &#123;unsigned bit:1; &#125;;int main()&#123; Empty e; Bit b; std::cout &lt;&lt; \"size of empty class: \" &lt;&lt; sizeof e &lt;&lt; '\\n' &lt;&lt; \"size of pointer : \" &lt;&lt; sizeof &amp;e &lt;&lt; '\\n'// &lt;&lt; \"size of function: \" &lt;&lt; sizeof(void()) &lt;&lt; '\\n' // compile error// &lt;&lt; \"size of incomplete type: \" &lt;&lt; sizeof(int[]) &lt;&lt; '\\n' // compile error// &lt;&lt; \"size of bit field: \" &lt;&lt; sizeof b.bit &lt;&lt; '\\n' // compile error &lt;&lt; \"size of array of 10 int: \" &lt;&lt; sizeof(int[10]) &lt;&lt; '\\n';&#125; 输出 （系统为32位指针，32位int系统） size of empty class: 1size of pointer : 4size of array of 10 int: 40 sizeof... 操作符（C++11），查询参数组中的元素个数。 语法： sizeof...(parameter_pack) 返回std::size_t类型对象。 示例： template&lt;class... Args&gt;std::size_t f()&#123; return sizeof...(Args);&#125; int main()&#123; std::cout &lt;&lt; f&lt;&gt;() &lt;&lt; '\\n' &lt;&lt; f&lt;int&gt;() &lt;&lt; '\\n' &lt;&lt; f&lt;char, int, double&gt;() &lt;&lt; '\\n';&#125; 输出： 013 tip: 三元表示式 ? : 问号后面的两个操作数必须为同一类型。 tip: 初始化列表在生成对象时才会随相应的构造函数一起调用。","tags":[{"name":"C++","slug":"C","permalink":"lindyer.github.io/source/tags/C/"}]},{"title":"微信小程序入门","path":"2017/01/10/微信小程序入门/","text":"微信开发者工具常用快捷键 CTRL + M 显示/隐藏模拟器CTRL + \\ 显示/隐藏侧边栏","tags":[{"name":"小程序","slug":"小程序","permalink":"lindyer.github.io/source/tags/小程序/"},{"name":"入门","slug":"入门","permalink":"lindyer.github.io/source/tags/入门/"}]},{"title":"Git学习","path":"2017/01/02/Git学习/","text":"Git下载 、 Github for Desktop 安装完成后（Windows下右键菜单会出现Git Bash，Linux和mac则通过命令行Git查看是否安装成功），还需要最后一步设置，在，命令行输入： $ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 【创建版本库】 参考链接：廖雪峰的官方网站","tags":[{"name":"入门","slug":"入门","permalink":"lindyer.github.io/source/tags/入门/"},{"name":"Git","slug":"Git","permalink":"lindyer.github.io/source/tags/Git/"}]},{"title":"Hexo  学习","path":"2016/12/31/Hexo-学习/","text":"[简介] ​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo官网 、Hexo文档 以下为windows的安装步骤 [安装前提] Node.js + Git [开始安装] 以下命令在git bash下执行 $ npm install -g hexo-cli npm（全称Node Package Manager，即node包管理器）是Node.js预设的、以JavaScript编写的软件管理系统。 hexo-cli 是hexo的客户端 [验证] PS： md图片插入 ![图片名称，可省略](图片URL) [主题下载] — 命令：git clone &lt;仓库&gt; &lt;存放路径&gt;；以后的操作以此路径为根目录 [初始化博客目录] — 命令：hexo init &lt;路径&gt; hexo init F:\\Blogcd F:\\Blognpm install [写博客] — 命令： hexo new &lt;文章名称&gt; hexo new \"Hexo学习\" 生成的MarkDown文件在：根目录下source/_posts/ 编写Hexo学习.md ，我这里采用的 Typora，具体的语法操作详见：http://wowubuntu.com/markdown/ md文件有个Front Matter，文件开头处可以增添一些解析参数。 title: Hexo 学习date: 2016-12-31 12:07:39tags: [Hexo,入门] 其中，tags则是文章的标签，可用于快速检索。 [本地预览] hexo clean &amp;&amp; hexo s [发布] hexo clean;hexo generate;hexo deploy; [用别名简化命令] windows下，默认是没有.bashrc，利用Git Bash在系统的管理员目录C:\\Users\\Administrator新建.bashrc touch .bashrc 在里面添加别名，如下 alias hd=\"hexo clean;hexo generate;hexo deploy;\" #发布alias hs=\"hexo clean &amp;&amp; hexo s\" #本地预览 [结尾]为文章加点音乐，下面标签直接插入MD文件(Markdown兼容HTML) &lt;center&gt;&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=694286&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; &lt;/center&gt;","tags":[{"name":"入门","slug":"入门","permalink":"lindyer.github.io/source/tags/入门/"},{"name":"Hexo","slug":"Hexo","permalink":"lindyer.github.io/source/tags/Hexo/"}]},{"title":"MarkDown学习","path":"2016/12/29/MarkDown学习/","text":"【概述】：Markdown是一种适用于网络的书写语言，易读易写；Markdown中文文档 【兼容HTML】：其兼容HTML，但与HTML不同是的，HTML是一种发布的格式，MarkDown是一种书写的格式，Markdown的格式语法只涵盖存文本可以涵盖的范围。不在Markdown涵盖范围的标签，可以直接在文档里面用HTML撰写，不需要额外标注这是HTML或者Markdown；只要直接加标签就可以了。要制约的只有一些HTML区块标签，比如&lt;div&gt; 、&lt;table&gt;、&lt;pre&gt;、 &lt;p&gt;等标签，必须在前后加上空行与其他内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格缩进。Markdown的生成器有足够智能，不会再HTML区块标签外加上不必要的&lt;p&gt; 标签。 【特殊字符自动转换】 ：在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。 区块元素【段落和换行】 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 标签。 如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 ，但是简单地「每个换行都转换为 」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 【标题】(类 Atx 形式)在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1## 这是 H2###### 这是 H6 【区块引用Blockquotes】 Markdown 标记区块引用是使用类似 email 中用&gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： wiki&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(\"echo $input | $markdown_script\"); 上面 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 【列表】Markdown 支持有序列表和无序列表。 无序列表使用星号*、加号+或是减号-作为列表标记（中间用空格分隔）： * Red* Green* Blue 有序列表则使用数字接着一个英文句点： 1. Bird2. McHale3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果;如果内容存在类似写法(数字-句点-空白)，则需要对.转义\\. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 【代码区块】 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;prev&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 【分隔线】 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线 ***--- 区段元素【链接】Markdown支持两种形式的链接语法：行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ \"Title\") inline link.[This link](http://example.net/) has no title attribute. This is an example inline link This link has no title attribute. 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. This is [an example][id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ \"Optional Title Here\" 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 链接网址也可以用尖括号包起来 [id]: &lt;http://example.com/&gt; \"Optional Title Here\" 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here \"Optional Title Here\" 【强调】 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks*_single underscores_**double asterisks**__double underscores__ 【代码】 如果要标记一小段行内代码，你可以用反引号把它包起来（`` ），例如： Use the `printf()` function. 【图片】 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg \"Optional title\") 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image \"Optional title attribute\" 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其他【自动链接】 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 【反斜杠】 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 参考链接：Markdown语法说明（简体中文）","tags":[{"name":"入门","slug":"入门","permalink":"lindyer.github.io/source/tags/入门/"},{"name":"MarkDown","slug":"MarkDown","permalink":"lindyer.github.io/source/tags/MarkDown/"}]}]